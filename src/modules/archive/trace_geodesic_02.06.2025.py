import sys
import numpy as np
from numpy.linalg import norm
import meshlib.mrmeshpy as mrmesh

sys.path.append(r"C:\Users\merli\Desktop\BA_thesis\sfc_python_implementation\functions&classes")
from SurfacePoint_mod import SurfacePoint

import numpy as np

import numpy as np

import numpy as np


import numpy as np

def is_vector_in_cone(H, A, B, C, tol=1e-8):
    """
    Determines if vector H lies within the cone generated by vectors A, B, and C.
    Also checks if H is colinear with any of the generators.

    Parameters:
    - H: numpy array of shape (3,), the vector to test.
    - A, B, C: numpy arrays of shape (3,), the cone generators.
    - tol: float, tolerance for numerical comparisons.

    Returns:
    - A string: "CONTAINED", "COLINEAR", or "NOT_CONTAINED"
    """

    # Early test: check if A and B are colinear
    cross_AB = np.cross(A, B)
    if np.linalg.norm(cross_AB) < tol:
        # A and B are (approximately) colinear
        D = np.cross(A, C)
        x = np.dot(D, H)
        if x > tol:
            return "CONTAINED"
        elif -tol <= x <= tol:
            return "COLINEAR"
        else:
            return "NOT_CONTAINED"
    else:
        # Early test: is H colinear with any of the generators directly?
        for vec in [A, B]:
            if np.linalg.norm(np.cross(H, vec)) < tol:
                return "COLINEAR"

        # Build matrix M with A, B, C as columns
        M = np.column_stack((A, B, C))

        try:
            coeffs = np.linalg.solve(M, H)
        except np.linalg.LinAlgError:
            print("Matrix is singular: A, B, C may be linearly dependent or ill-conditioned.")
            return "ERROR"

        # Check for strictly positive coefficients (inside cone)
        if np.all(coeffs > tol):
            return "CONTAINED"
        else:
            return "NOT_CONTAINED"


def flatten_unique(pairs):
    result = []
    seen = set()
    for pair in pairs:
        for item in pair:
            if item not in seen:
                seen.add(item)
                result.append(item)

    # Now check the border condition
    if [result[0], result[-1]] in pairs or [result[-1], result[0]] in pairs:
        on_the_border = False
    else:
        on_the_border = True

    return result, on_the_border


def sort_edges_into_loop(edges):
# this helper function is used in the vertex CASE of the next_step function
# edges is a list of lists, with the inner lists always containing two vertex indices (which signify an edge)
    if not edges:
        return []

    from collections import defaultdict

    # Create a mapping from each vertex to its connected edges
    edge_map = defaultdict(list)
    for a, b in edges:
        edge_map[a].append(b)
        edge_map[b].append(a)

    # Start from an arbitrary vertex
    start = edges[0][0]
    path = [start]
    visited = set([start])

    current = start
    while True:
        neighbors = edge_map[current]
        next_vertex = None
        for neighbor in neighbors:
            if neighbor not in visited:
                next_vertex = neighbor
                break
        if next_vertex is None:
            break
        path.append(next_vertex)
        visited.add(next_vertex)
        current = next_vertex

    # Convert path to edge list
    sorted_edges = [[path[i], path[i + 1]] for i in range(len(path) - 1)]
    if path[0] in edge_map[path[-1]]:
        sorted_edges.append([path[-1], path[0]])

    # NOW: flatten to list of indices
    flat_indices = [v for edge in sorted_edges for v in edge]

    # check if the SurfacePoint lies on the border of the mesh
    if flat_indices[0] == flat_indices[-1]:
        on_the_border = False
    else: 
        on_the_border = True

    # Remove duplicates while preserving order
    seen = set()
    unique_indices = [x for x in flat_indices if not (x in seen or seen.add(x))]

    return unique_indices, on_the_border


import numpy as np

def next_step(tri_mesh, iterate_point, direction, just_traversed=None, tol=1e-8):

    assert isinstance(direction, np.ndarray)
    assert iterate_point.type in ['vertex', 'edge', 'face']
    
    print(f"\n=========================")
    print(f"CALL TO next_step()")
    print(f"Iterate type: {iterate_point.type}")
    print(f"Input direction: {direction}")
    print(f"Just traversed: {just_traversed}")
    print("=========================")

    type_of_iterate_point = iterate_point.type
    
    if type_of_iterate_point == 'vertex':
        # ------------------- VERTEX CASE -------------------
        vertex_index = iterate_point.top_indices[0]
        face_indices = tri_mesh.vertex_faces[vertex_index]
        print(f"\n--- Vertex case ---")
        print(f"Vertex index: {vertex_index}")
        print(f"Faces connected: {face_indices}")

        # Build list of all neighboring vertices (edge pairs)
        vertice_pairs = [[v for v in tri_mesh.faces[face_index] if v != vertex_index] for face_index in face_indices]
        vertice_edges = [tuple(pair) for pair in vertice_pairs]  # turn lists into proper (v1,v2) tuples

        vertice_pairs, on_the_border = flatten_unique(vertice_pairs)

        #vertice_pairs, on_the_border = sort_edges_into_loop(vertice_pairs)

        #vertice_pairs, on_the_border = sort_edges_into_loop(vertice_pairs)

        print(f"Sorted loop of neighboring vertices: {vertice_pairs}")
        print(f"On border: {on_the_border}")

        vec1 = tri_mesh.vertices[vertice_pairs[0]] - iterate_point.coord3d
        vec2 = tri_mesh.vertices[vertice_pairs[-1]] - iterate_point.coord3d
        vec3 = tri_mesh.vertex_normals[vertex_index]

        cone_result = is_vector_in_cone(direction, vec1, vec2, vec3, tol=1e-8)
        print(f"Initial cone evaluation: {cone_result}")

        if on_the_border and cone_result == "NOT_CONTAINED":
            print("Direction points outside mesh at boundary vertex.")
            return None

        if just_traversed is not None:
            #print("Traversal reduction not implemented yet.")
            return 

        Found_it = False
        iteration_step = 0

        while not Found_it and iteration_step < 30:
            print(f"\nSubdivision iteration {iteration_step}")
            print(f"Current vertice_pairs: {vertice_pairs}")

            index1 = vertice_pairs[0]
            index2 = vertice_pairs[(len(vertice_pairs) + 1) // 2]
            vertice_pairs_subset = vertice_pairs[index1:index2]

            print(f"Testing sector: ({index1}, {index2})")

            v1 = tri_mesh.vertices[index1]
            v2 = tri_mesh.vertices[index2]
            vec1 = v1 - iterate_point.coord3d
            vec2 = v2 - iterate_point.coord3d
            vec3 = tri_mesh.vertex_normals[vertex_index]

            alignment = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)
            print(f"Cone result: {alignment}")

            if alignment == "COLINEAR":
                x = np.dot(direction, vec1)
                print(f"Colinear projection dot product: {x}")
                if x > tol:
                    vertex = [index1]
                else:
                    vertex = [index2]
                Found_it = True
                just_traversed = [vertex[0], vertex_index]
                print(f"COLINEAR step → moving to vertex {vertex}")
                return vertex, just_traversed

            elif alignment == "CONTAINED":
                print("Direction lies inside cone → narrowing search.")
                vertice_pairs = vertice_pairs_subset

            else:
                remove = vertice_pairs_subset[1:-1]
                vertice_pairs = [v for v in vertice_pairs if v not in remove]
                print(f"Outside cone: removing vertices {remove}, new pairs {vertice_pairs}")

            if len(vertice_pairs) == 2:
                Found_it = True
                just_traversed = vertice_pairs + [vertex_index]
                print(f"Sector reduced to edge: {vertice_pairs}")
                return [vertice_pairs[0], vertice_pairs[1]], just_traversed

            iteration_step += 1

    elif type_of_iterate_point == 'edge':
        # ------------------- EDGE CASE -------------------
        edge = iterate_point.top_indices
        ver1 = tri_mesh.vertices[edge[0]]
        ver2 = tri_mesh.vertices[edge[1]]
        edge_vec = ver1 - ver2
        edge_sorted = np.sort(edge)

        print(f"\n--- Edge case ---")
        print(f"Edge indices: {edge}")
        print(f"Edge vector: {edge_vec}")

        distance, index = tri_mesh.face_adjacency_edges_tree.query(edge_sorted)
        face_index1, face_index2 = tri_mesh.face_adjacency[index]
        print(f"Adjacent faces: {face_index1}, {face_index2}")

        at_border_of_mesh = distance >= 0
        first_step = just_traversed is None

        if at_border_of_mesh and not first_step: 
            print("Reached mesh boundary during edge traversal.")
            return None
        
        elif at_border_of_mesh and first_step: 
            face_index = iterate_point.face_index
            inward_dir = np.cross(tri_mesh.face_normals[face_index], ver1 - iterate_point.coord3d)
            dot = np.dot(direction, inward_dir)
            print(f"Border condition dot product: {dot}")

            if dot < -tol:
                print("Direction points outside from mesh border.")
                return None

        else:
            if just_traversed is None:
                cross_norm = np.linalg.norm(np.cross(direction, edge_vec))
                print(f"Colinearity test: cross product norm: {cross_norm}")
                if cross_norm < tol:
                    dot = np.dot(direction, edge_vec)
                    just_traversed = edge
                    print(f"Dot product along edge: {dot}")
                    if dot > tol:
                        print("Colinear → stepping forward along edge.")
                        return [edge[0]], just_traversed
                    elif dot < -tol:
                        print("Colinear → stepping backward along edge.")
                        return [edge[1]], just_traversed
                    else:
                        return None
            else:
                # Determine which face we're entering
                if sorted(tri_mesh.faces[face_index1]) == sorted(just_traversed):
                    next_face_index = face_index2
                else:
                    next_face_index = face_index1

                third_vertex_index = list(set(tri_mesh.faces[next_face_index]) - set(iterate_point.top_indices))[0]
                third_vertex = tri_mesh.vertices[third_vertex_index]

                print(f"Next face: {next_face_index}")
                print(f"Third vertex index: {third_vertex_index}")
                print(f"Third vertex coord: {third_vertex}")

                vec1 = third_vertex - iterate_point.coord3d
                vec2 = tri_mesh.vertices[edge[0]] - iterate_point.coord3d
                vec3 = tri_mesh.face_normals[next_face_index]

                x = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)
                print(f"Cone evaluation result: {x}")

                if x == "CONTAINED":
                    to_return = [edge[0], third_vertex_index]
                elif x == "NOT_CONTAINED":
                    to_return = [edge[1], third_vertex_index]
                else:
                    to_return = [third_vertex_index]

                print(f"Edge traversal result: {to_return}")
                return to_return, tri_mesh.faces[next_face_index]

    else:
        # ------------------- FACE CASE -------------------
        print(f"\n--- Face case ---")
        point = iterate_point.coord3d
        face_index = iterate_point.face_index
        vertex_index1, vertex_index2, vertex_index3 = iterate_point.top_indices
        vertex1 = tri_mesh.vertices[vertex_index1]
        vertex2 = tri_mesh.vertices[vertex_index2]
        vertex3 = tri_mesh.vertices[vertex_index3]

        vec1 = vertex1 - point
        vec2 = vertex2 - point
        vec3 = tri_mesh.face_normals[face_index]

        containment1 = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)
        print(f"First cone test: {containment1}")

        if containment1 == "NOT_CONTAINED":
            vec2b = vertex3 - point
            containment2 = is_vector_in_cone(direction, vec1, vec2b, vec3, tol=tol)
            print(f"Second cone test: {containment2}")
            if containment2 == "NOT_CONTAINED":
                to_return = [vertex_index2, vertex_index3]
            elif containment2 == "CONTAINED":
                to_return = [vertex_index1, vertex_index3]
            else:
                to_return = [vertex_index3]
        elif containment1 == "CONTAINED":
            to_return = [vertex_index1, vertex_index2]
        else:
            cross_norm = np.linalg.norm(np.cross(direction, vec1))
            print(f"Face colinearity cross product norm: {cross_norm}")
            if cross_norm < tol:
                to_return = [vertex_index1]
            else:
                to_return = [vertex_index2]

        print(f"Face traversal result: {to_return}")
        return to_return, [vertex_index1, vertex_index2, vertex_index3]




def trace_geodesic(tri_mesh, meshlib_mesh, start_point, direction, distance):
    #start_point is given as a SurfacePoint instance
    #direction is a vector in the tangent space at the point and given like this: [x,y,z]
    #distance is a float


    path = []
    path_length = 0.0

    iterate_point = start_point
    last_origin_type = start_point.face_index
    iterate_direction = direction

    while distance_travelled < distance:

        next_step(tri_mesh, iterate_point, iterate_direction, last_origin_type)




        path_length += segment



            

                #vertices = [tri_mesh.vertices[i] for i in vertex_indices - vertex_index]
                





    

    x, y, z = point1.coord3d
    mtp1 = mrmesh.findProjection(mrmesh.Vector3f(x, y, z), meshlib_mesh).mtp

    # Here generate a Vector3f from direction list:
    vec3f = mrmesh.Vector3f(direction[0], direction[1], direction[2])

    end = mtp1
    path_middle = mrmesh.trackSection(meshlib_mesh, mtp1, end, vec3f, distance)

    path = [point1]

    for i in range(path_middle.__len__()):
        ep = path_middle.__getitem__(i)
        vec3f = meshlib_mesh.edgePoint(ep)
        sp = SurfacePoint.from_position([vec3f[0], vec3f[1], vec3f[2]], tri_mesh)
        path.append(sp)

    geodesic_length = 0.0
    for i in range(len(path) - 1): 
        segment_len = norm(np.array(path[i].coord3d) - np.array(path[i + 1].coord3d))
        geodesic_length += segment_len

    print(f"[INFO] Geodesic length: {geodesic_length}")
    return path, geodesic_length
