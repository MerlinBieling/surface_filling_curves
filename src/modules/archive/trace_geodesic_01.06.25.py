import sys
import numpy as np
from numpy.linalg import norm
import meshlib.mrmeshpy as mrmesh

sys.path.append(r"C:\Users\merli\Desktop\BA_thesis\sfc_python_implementation\functions&classes")
from SurfacePoint_mod import SurfacePoint

import numpy as np

import numpy as np

import numpy as np


import numpy as np

def is_vector_in_cone(H, A, B, C, tol=1e-8):
    """
    Determines if vector H lies within the cone generated by vectors A, B, and C.
    Also checks if H is colinear with any of the generators.

    Parameters:
    - H: numpy array of shape (3,), the vector to test.
    - A, B, C: numpy arrays of shape (3,), the cone generators.
    - tol: float, tolerance for numerical comparisons.

    Returns:
    - A string: "CONTAINED", "COLINEAR", or "NOT_CONTAINED"
    """

    # Early test: check if A and B are colinear
    cross_AB = np.cross(A, B)
    if np.linalg.norm(cross_AB) < tol:
        # A and B are (approximately) colinear
        D = np.cross(A, C)
        x = np.dot(D, H)
        if x > tol:
            return "CONTAINED"
        elif -tol <= x <= tol:
            return "COLINEAR"
        else:
            return "NOT_CONTAINED"
    else:
        # Early test: is H colinear with any of the generators directly?
        for vec in [A, B]:
            if np.linalg.norm(np.cross(H, vec)) < tol:
                return "COLINEAR"

        # Build matrix M with A, B, C as columns
        M = np.column_stack((A, B, C))

        try:
            coeffs = np.linalg.solve(M, H)
        except np.linalg.LinAlgError:
            print("Matrix is singular: A, B, C may be linearly dependent or ill-conditioned.")
            return "ERROR"

        # Check for strictly positive coefficients (inside cone)
        if np.all(coeffs > tol):
            return "CONTAINED"
        else:
            return "NOT_CONTAINED"




def sort_edges_into_loop(edges):
# this helper function is used in the vertex CASE of the next_step function
    if not edges:
        return []

    from collections import defaultdict

    # Create a mapping from each vertex to its connected edges
    edge_map = defaultdict(list)
    for a, b in edges:
        edge_map[a].append(b)
        edge_map[b].append(a)

    # Start from an arbitrary vertex
    start = edges[0][0]
    path = [start]
    visited = set([start])

    current = start
    while True:
        neighbors = edge_map[current]
        next_vertex = None
        for neighbor in neighbors:
            if neighbor not in visited:
                next_vertex = neighbor
                break
        if next_vertex is None:
            break
        path.append(next_vertex)
        visited.add(next_vertex)
        current = next_vertex

    # Convert path to edge list
    sorted_edges = [[path[i], path[i + 1]] for i in range(len(path) - 1)]
    if path[0] in edge_map[path[-1]]:
        sorted_edges.append([path[-1], path[0]])

    # NOW: flatten to list of indices
    flat_indices = [v for edge in sorted_edges for v in edge]

    # check if the SurfacePoint lies on the border of the mesh
    if flat_indices[0] == flat_indices[-1]:
        on_the_border = False
    else: 
        on_the_border = True

    # Remove duplicates while preserving order
    seen = set()
    unique_indices = [x for x in flat_indices if not (x in seen or seen.add(x))]

    return unique_indices, on_the_border


import numpy as np

def next_step(tri_mesh, iterate_point, direction, just_traversed = None, tol=1e-8):
    # given the last iterate this function yields the indices of the next edge or vertex that the geodesic should cross
    # this function does NOT yield the exact location on an edge.
    # this function is already given the direction in which the next point must lie

    # start_point is given as a SurfacePoint instance
    # direction is a vector in the tangent space at the point and given like this: [x,y,z]
    # distance is a float
    # origin type should be either a face index in a list (if a face was traversed in the last step)
    # or two vertex_indices (if along an edge was traversed)
    # or SurfacePoints Face_index if we are at the first step

    # THIS FUNCTION CAN BE MADE MORE EFFICIENT IF YOU MAKE USE OF INFO ABOUT 
    # THE EDGE/FACE THAT WAS LAST TRAVERSED
    # ALSO: Trimesh facets_boundary could be used to directly traverse whole facets, which would be mor eefficient

    type_of_iterate_point = iterate_point.type
    if type_of_iterate_point == vertex:

        vertex_index = iterate_point.top_indices[0]

        face_indices = tri_mesh.vertex_faces[vertex_index]

        # this generates a list of vertice pairs, each a potential edge that our path might cross
        vertice_pairs = [ [v for v in tri_mesh.faces[face_index] if v != vertex_index] for face_index in face_indices ]

        vertice_pairs, on_the_border = sort_edges_into_loop(vertice_pairs)

        # from now on the vertice_pairs list contains a list of vertices [x,y,z] where x would be connected to y, y to z, z (potentially) to x

        if on_the_border == True and is_vector_in_cone(vertice_pairs[0], vertice_pairs[-1]) == "NOT_CONTAINED":
            print("Invalid direction pointing outside of the mesh given")
            return None

        # vertice_pairs can be reduced, depending on wether just_traversed signals an edge (minus two faces)
        # or wether it signals a face (minus one face)

        #if len(just_traversed) == 2:
            # we just traversed an edge, the adjacent faces wont have to be checked

        #elif len(just_traversed) == 3:
            # we just traversed a face, the face wont have to be checked
        

        #else:
            # no reduction is taking place, just move on


        else:

            Found_it = False
            iteration_step = 0

            while Found_it == False and iteration_step < 30:

                # in this next bit we will determine in which part of the 3d space the vector lies

                index1 = vertice_pairs[0]
                index2 = (len(vertice_pairs) + 1) // 2

                vertice_pairs_subset = vertice_pairs[index1:index2]

                v1 = tri_mesh.vertices[index1]
                v2 = tri_mesh.vertices[index2]

                vec1 = v1 - iterate_point.coord3d
                vec2 = v2 - iterate_point.coord3d
                vec3 = tri_mesh.vertex_normals[iterate_point.top_indices[0]]

                alignment = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)

                if alignment == "COLINEAR":
                    # in this case the path segment is going from a vertex to a vertex
                    x = np.dot(direction, vec1)
                    if x > tol:
                        vertex = [index1]
                    else:
                        vertex = [index2]
                    Found_it = True

                    just_traversed = [vertex[0], vertex_index]

                    return vertex, just_traversed

                elif alignment == "CONTAINED":
                    vertice_pairs = vertice_pairs_subset

                else: 
                    remove = vertice_pairs_subset[1:-1]
                    vertice_pairs = [v for v in vertice_pairs if v not in remove]

                if len(vertice_pairs) == 2:
                    # in this case the path segment is going from a vertex to and egde, crossing a face
                    Found_it = True
                    just_traversed = vertice_pairs + [vertex_index]
                    return [vertice_pairs[0], vertice_pairs[1]], just_traversed

                iteration_step += 1


    elif type_of_iterate_point == edge:

        edge = iterate_point.top_indices
        edge_vec = edge[0] - edge[1]


        if just_traversed == None:

            if 
            elif np.linalg.norm(np.cross(direction, edge_vec)) < tol:
                # vectors are colinear, this could only happen at the start point...
                # when the start point lies on an edge and the direction is the edge vector
                dot = np.dot(direction, edge_vec)
                just_traversed = edge
                if dot > tol:
                    # vectors point in the same direction
                    return [edge[0]], just_traversed
                elif dot < -tol:
                    #vectors point in oposite directions
                    return [edge[1]], just_traversed
                else:
                    return None
                    # probably degenerate or noisy
            else:
        else: 
            edge_sorted = np.sort(edge)
            distance, index = tri_mesh.face_adjacency_edges_tree.query(edge_sorted)
            face_index1, face_index2 = tri_mesh.face_adjacency[index]

            if tri_mesh.vertices[face_index1] == just_traversed:
                # work with face_index2
                next_face_index = face_index2
            else:
                next_face_index = face_index1

            third_vertex_index = tri_mesh.faces[next_face_index] - iterate_point.top_indices

            third_vertex = tri_mesh.vertices[third_vertex_index]

            vec1 = third_vertex - iterate_point.coord3d
            vec2 = tri_mesh.vertices[edge[0]] - iterate_point.coord3d
            vec3 = tri_mesh.face_normals[next_face_index]

            x = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)

            if x == CONTAINED:
                to_return = [edge[0], third_vertex_index]

            elif x == NOT_CONTAINED:
                to_return = [edge[1], third_vertex_index]
                
            else:
                to_return = [third_vertex_index]
                
            return to_return, tri_mesh.faces[next_face_index] # THIS WOULD BE MORE EFFICIENT IF RETURNING next_face_index -> WIP

    else: 
        # this of course only occurs in the very beginning, if the first point lies on the inside of a face
        # this means ofc that just_traversed = None
        point = iterate_point.coord3d
        face_index = iterate_point.face_index

        ver1 = iterate_point.top_indices[0] #these are vertex indices
        ver2 = iterate_point.top_indices[1]
        ver3 = iterate_point.top_indices[2]

        vec1 = ver1 - point
        vec2 = ver2 - point
        vec3 = tri_mesh.face_normals[iterate_point.face_index]

        containment1 = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)

        if containment1 == NOT_CONTAINED:
            vec2 = ver3 -point
            containment2 = is_vector_in_cone(direction, vec1, vec2, vec3, tol=tol)
            if containment2 == NOT_CONTAINED:
                to_return = [ver2, ver3]
            elif containment2 == CONTAINED:
                to_return = [ver1, ver3]
            else: 
                #colinearity, and it must be with the new guy, ver3
                to_return = [ver3]
        elif containment1 == CONTAINED:
            to_return == [ver1, ver2]
        else:
            # the next step either lies on ver1 or on ver2
            if np.linalg.norm(np.cross(direction, vec1)) < tol:
                to_return = [ver1]
            else:
                to_return = [ver2]

        return to_return, [ver1,ver2,ver3]







def trace_geodesic(tri_mesh, meshlib_mesh, start_point, direction, distance):
    #start_point is given as a SurfacePoint instance
    #direction is a vector in the tangent space at the point and given like this: [x,y,z]
    #distance is a float


    path = []
    path_length = 0.0

    iterate_point = start_point
    last_origin_type = start_point.face_index
    iterate_direction = direction

    while distance_travelled < distance:

        next_step(tri_mesh, iterate_point, iterate_direction, last_origin_type)




        path_length += segment



            

                #vertices = [tri_mesh.vertices[i] for i in vertex_indices - vertex_index]
                





    

    x, y, z = point1.coord3d
    mtp1 = mrmesh.findProjection(mrmesh.Vector3f(x, y, z), meshlib_mesh).mtp

    # Here generate a Vector3f from direction list:
    vec3f = mrmesh.Vector3f(direction[0], direction[1], direction[2])

    end = mtp1
    path_middle = mrmesh.trackSection(meshlib_mesh, mtp1, end, vec3f, distance)

    path = [point1]

    for i in range(path_middle.__len__()):
        ep = path_middle.__getitem__(i)
        vec3f = meshlib_mesh.edgePoint(ep)
        sp = SurfacePoint.from_position([vec3f[0], vec3f[1], vec3f[2]], tri_mesh)
        path.append(sp)

    geodesic_length = 0.0
    for i in range(len(path) - 1): 
        segment_len = norm(np.array(path[i].coord3d) - np.array(path[i + 1].coord3d))
        geodesic_length += segment_len

    print(f"[INFO] Geodesic length: {geodesic_length}")
    return path, geodesic_length
